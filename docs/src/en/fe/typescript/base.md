#TypeScript Basics

`TypeScript` is a superset of the `JavaScript` language. It adds optional type annotations to `JavaScript`, which greatly enhances the readability and maintainability of the code. At the same time, it provides the latest and evolving JavaScript features, allowing us to build more robust components.

Quoting the definition from [official website](https://www.typescriptlang.org/zh/)

> `TypeScript` extends `JavaScript`, adding type support to it.
>
> `TypeScript` can improve your development experience by finding errors and providing fixes before you run your code.
>
> Any browser, any operating system, anywhere running `JavaScript`, completely open source.

Files written in `TypeScript` have the `.ts` suffix; when using `TypeScript` to write `React`, they have the `.tsx` suffix.

## type of data

### Primitive type

`TypeScript` provides the same primitive types as `JavaScript`

#### boolean Boolean type

Boolean types are simply `true / false` values

```ts
let isFlag: boolean = true
```

#### string string type

```ts
let name: string = 'maomao'
name = 'Maomao'
```

#### number number type

Like `JavaScript`, all numbers in `TypeScript` are floating point numbers. The type of these floating point numbers is `number`. In addition to supporting decimal and hexadecimal literals, `TypeScript` also supports binary and octal literals introduced in `ES6`.

```ts
let decLiteral: number = 20
let hexLiteral: number = 0x14
let binaryLiteral: number = 0b10100
let octalLiteral: number = 0o24
```

#### `bigint`

The `bigint` type represents an arbitrary-precision integer and can be used to handle integers beyond the range of the `JavaScript` `number` type.

```ts
let big: bigint = 19961996n
```

#### `symbol`

The `symbol` type represents a unique value, which must be generated by the `Symbol` function. It is often used to create unique identifiers for object properties.

```ts
let sym: symbol = Symbol('maomao')
sym = Symbol('Maomao') // OK
sym = 'Maomao' // Error
```

### `object`

The `object` type represents non-primitive types, that is, types other than `boolean` `string` `number` `bigint` `symbol` `null` `undefined`.

Using the `object` type can better represent `API` like `Object.create`

```ts
declare function create(o: object | null): void

create({ prop: 0 }) // OK
create(null) // OK

create(42) // Error
create('string') // Error
create(false) // Error
create(undefined) // Error
```

### Special types

In addition to some of the primitive types mentioned above, there are also some special types in `TypeScript`

- `any` any value
- `void` null value
- `null`
- `undefined`

#### `any` Any value

`any` is a special type. When a value is of type `any`, `TypeScript` will not perform type checking on it.

```ts
/* You can manipulate your variables in any way TypeScript will not throw relevant prompts */
let value: any = 1
free = { name: 'maomao' }
free.log()
free = 'Maomao'
```

:::warning Notes
The `any` type, whether specified by the developer or implicitly inferred by `TypeScript`, will cause `TypeScript` to lose accurate type inference capabilities, which may lead to missing some runtime errors, violating the rules of using `TypeScript` original intention
:::

#### `void` empty value

`JavaScript` does not have the concept of void. In `TypeScript`, `void` can be used to represent a function without any return value.

```ts
function sayHello(): void {
  console.log('Hello, world')
}
```

You can also define a variable of type `void`, but such a variable is meaningless because you can only assign `undefined` and `null` to it

```ts
let value: void = undefined
```

#### `null` and `undefined`

In `TypeScript`, these two primitive data types can be defined using `null` and `undefined`

```ts
let u: undefined = undefined
let n: null = null
```

By default `null` and `undefined` are subtypes of all types. That is to say, you can assign `null` and `undefined` to variables of type `number`.

When the compile option specifies `--strictNullChecks` (enable strict null checking mode), `null` and `undefined` are only allowed to be assigned to variables of type themselves or `any`, which can avoid many common problems

### `unknown` Unknown type

The `unknown` type is used to describe a variable whose type we donâ€™t yet know

Just as all types can be classified as `any`, all types can be classified as `unknown`. This makes `unknown` another top-level type in the `TypeScript` type system

```ts
let notSure: unknown = 4
notSure = 'maybe a string instead'
notSure = false // can also be a boolean
```

:::tip `unknown` and `any`
Compared to the `any` type, which does not perform any checks on variables, variables of the `unknown` type must be checked accordingly when performing most operations, so the `unknown` type is relatively more strict.
:::

### `never`

The `never` type represents the type of values that never exist. It is often used for a function that never returns a value, or a function that always throws an error.

```ts
// There will be no return value
function infiniteLoop(): never {
  while (true) {}
}

// Function that always throws an error
function error(message: string): never {
  throw new Error(message)
}
```

A `never` type can only be assigned to another `never` type

### Type inference and type annotations

- **Type annotation**: Explicitly specify the type of the variable
- **Type inference**: `TypeScript` automatically infers variable types based on contextual content

```ts
let name: string = 'maomao'
let age = 18 // TypeScript automatically infers job: number
```

:::tip

- When assigning a clear value to a variable, it is recommended to use **type annotations** as much as possible
- For function return values, it is a better practice to always explicitly indicate the return type

:::

### Array

In `TypeScript`, array type declarations have two forms: `type[]` and **generic**

Define the array type by **type + square brackets**:

```ts
// Only string types are allowed to be stored
const strArray: string[] = ['1', '2', '3']
//Only number types are allowed to be stored
const numArray: number[] = [1, 2, 3]
// any type
const anyArray: any[] = ['maomao', 18, {}]
```

Define array types via **generics**:

```ts
// Only string types are allowed to be stored
const strArray: Array<string> = ['1', '2', '3']
//Only number types are allowed to be stored
const numArray: Array<number> = [1, 2, 3]
// any type
const anyArray: Array<any> = ['maomao', 18, {}]
```

### Tuple Tuple

The Tuple type represents a fixed-length array, and the type corresponding to each item is known

`TypeScript` will report an error when **out-of-bounds access** or **assigning the wrong type value** to tuple type data

```ts
const tuple: [string, number] = ['maomao', 18]

console.log(tuple[2]) // Error
tuple[0] = 666 // Error
```

### Enumeration type Enum

The `enum` type is an addition to the `JavaScript` standard data types. Like other languages such as `C#`, you can use enumeration types to give friendly names to a set of values.

```ts
enum Color {
  Red,
  Green,
  Blue
}
const c: Color = Color.Green
```

By default, element numbering starts with `0`. You can also manually specify member values. For example, let's change the above example to start numbering from `1`:

```ts
enum Color {
  Red = 1,
  Green,
  Blue
}
const c: Color = Color.Green
```

Or use manual assignment for everything:

```ts
enum Color {
  Red = 1,
  Green = 2,
  Blue = 4
}
const c: Color = Color.Green
```

One convenience provided by enumeration types is that you can derive its name from its values. For example, we know that the value is `2`, but we are not sure which name in `Color` it maps to, we can look up the corresponding name:

```ts
enum Color {
  Red = 1,
  Green,
  Blue
}
const colorName: string = Color[2]

console.log(colorName) // 'Green' because its value is 2 in the above code
```

::: tip enumeration summary

- When there is no initial value, the default is to start from `0` and increase automatically.
- When the first member is initially assigned a value of `10`, subsequent members start to grow from `10`
- Numeric type enumerations can be mapped, but string type enumerations cannot be mapped.
  - When an enumeration is of numeric type, the assigned variable can take a value beyond the enumeration value.
  - When an enumeration is of string type, the assigned variable can only take the enumeration members.
- If the nth member is assigned a value of type `string`, all members after n need to be initialized.
- The enumeration declared with `const` is a constant enumeration and will be removed after compilation.
- Constant enumerations are calculated directly at compile time As a result, enumerations of computed types compute the result at runtime
- It is not recommended to mix numeric types and string enumerations

:::

### Type of object - interface

In `TypeScript`, we use interfaces to define the types of objects.
An interface is a way to describe the shape of an object. It can define what properties and methods an object needs to have (the interface only places some restrictions on the type and does not create new objects in the code, that is, it will not be compiled into `JavaScript`)

```ts
interface Person {
  name: string
  age: number
}

const person: Person = {
  name: 'maomao',
  age: 18
}
```

In the above code, the `person` variable is of type `Person`, so it can only accept the attributes specified by the interface, and the type of the attribute value must also be consistent with that specified in the interface. When there is one more or one less attribute, TypeScript` will compile with errors\*\*

```ts{5,9}
interface Person {
   name: string
   age:number
}

// Error: Missing attribute "age"
const person1: Person = {
   name: 'maomao'
}
// Error: "gender" is not in type "Person"
const person2: Person = {
   name: 'Maomao',
   age: 18,
   gender: 'male'
}
```

#### Optional attributes

When we don't want to match a shape exactly, we can use a question mark (?) to mark an interface property as optional (meaning that this property can not exist)

```ts
interface Person {
  name: string
  age?: number
}

const person: Person = {
  name: 'maomao'
}
```

At this time **it is still not allowed to add undefined properties**

```ts{6}
interface Person {
   name: string
   age?: number
}

// Error: "gender" is not in type "Person"
const person: Person = {
   name: 'Maomao',
   age: 18,
   gender: 'male'
}
```

#### Any attribute

When we want an interface to allow arbitrary attributes, we can use the following method:

```ts
interface Person {
  name: string
  age?: number
  [propName: string]: any
}

const person: Person = {
  name: 'maomao',
  gender: 'male'
}
```

**Use `[propName: string]` to define any property to take a value of type `string`**

Note: **Once any attribute is defined, the type of both the determined attribute and the optional attribute must be a subset of its type**:

```ts{7}
interface Person {
   name: string
   age?: number
   [propName: string]: string
}

// Error: Property "age" is incompatible with index signature, type "number" cannot be assigned to type "string"
const person: Person = {
   name: 'Maomao',
   age: 18,
   gender: 'male'
}
```

Only one arbitrary property can be defined in an interface. If there are multiple types of properties in the interface, you can use union types in any of the properties:

```ts
interface Person {
  name: string
  age?: number
  [propName: string]: string | number
}

const person: Person = {
  name: 'Maomao',
  age: 18,
  gender: 'male'
}
```

#### Read-only properties

Sometimes we want some fields in the object to be assigned only when they are created, then we can use `readonly` to define read-only properties:

```ts{15}
interface Person {
   readonly id: number
   name: string
   age?: number
   [propName: string]: any
}

const person: Person = {
   id: 1,
   name: 'Maomao',
   age: 18,
   gender: 'male'
}

// Error: Cannot assign a value to "id" because it is a read-only property
person.id = 1996
```

**The read-only constraint exists when the object is assigned a value for the first time, not when the read-only property is assigned a value for the first time**:

```ts{8,15}
interface Person {
   readonly id: number
   name: string
   age?: number
   [propName: string]: any
}

// Error: Missing attribute "id"
const person: Person = {
   name: 'Maomao',
   age: 18,
   gender: 'male'
}

// Error: Cannot assign a value to "id" because it is a read-only property
person.id = 1996
```

### Type alias

Type aliases are defined using the `type` keyword, which gives an existing type a new name. It is mainly used to define some complex types: such as union types, intersection types, etc.

```ts
type ID = number

type Person = {
  name: string
  age: number
}
```

### Literal type

A literal type is a special type that represents a fixed value

**String literal type**:

```ts
type Name = 'maomao' | 'maomao1996' | 'Maomao'
```

**Numeric literal type**:

```ts
type Age = 18 | 19 | 20
```

**Boolean literal type**:

```ts
type IsLoggedIn = true
```

Using literal types allows for stricter type checking at compile time to avoid runtime errors caused by passing incorrect values. At the same time, literal types can also be used to define advanced types such as union types and intersection types to improve the readability and maintainability of the code.
