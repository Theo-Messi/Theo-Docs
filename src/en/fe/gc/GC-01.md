---
outline: deep
title: master package
editLink: true
head:
  - - meta
    - name: keywords
      content: package npm pnpm yarn engineering tsconfig
---

# Get to know package.json

`package.json` exists in every front-end engineering project based on `node`, so correctly understanding the fields in this file is particularly important for clarifying the project process and improving engineering capabilities.
`package.json` exists in every front-end engineering project based on `node`, so correctly understanding the fields in this file is particularly important for clarifying the project process and improving engineering capabilities.
每个基于node的前端工程项目中都存在package.json，因此正确理解该文件中的字段对于理清项目流程、提高工程能力尤为重要。
`package.json` exists in every front-end engineering project based on `node`, so correctly understanding the fields in this file is extremely important to clarify the project process and improve engineering capabilities.
每个基于 Node 的前端工程项目中都存在 package.json ，因此正确理解该文件中的字段对于理清项目流程、提升工程能力极为重要。

## introduce

The translated introduction in [Chinese Document](https://nodejs.cn/api/packages.html#introduction) is still difficult to understand. Simply put, `package.json` is a package (`package`) description file. When `node` processes the files in the package (such as module type identification, etc.), it will follow the nearest sibling or superior `package.json Rule processing described in `, in addition `package.json` does not take effect in the `node_modules` directory by default

## Generate

`package.json` can be generated manually or through the command:

```shell
# Enter the field content according to the prompts
npm init
# Generate all using default values
npm init -y
# yarn or pnpm also have the same command, the difference is that yarn and pnpm are generated by default, no need to add -y
# The content generated by pnpm is consistent with the default content of npm. The generated content by yarn only has the name and packageManager fields.
yarn init
pnpm init
```

## Fields used by Node

### type

Currently there are two mainstream modularization solutions for `JS`, namely `CommonJS` used by `Node` and the latest `ESModule`. For different module types, the engine will use different module parsers for processing, so it needs to be correct Identification module type

The default value of `type` is `commonjs`, so the files in the project will be parsed using the `CommonJS` module rules by default. If specified as `module`, the `ESModule` module rules will be used for analysis.

The official also extended the `.mjs` and `.cjs` extensions, corresponding to `ESModule` and `CommonJS` respectively. Files with these two extensions will always be parsed by the corresponding module parser and will not be restricted by the `type` field.

That is to say, if `type` is not specified or `commonjs` is specified, and `ESModule` syntax is used in the project, the corresponding file needs to be changed to `.mjs` extension. On the contrary, when `type` is specified as `module`, the `CommonJS` module should be changed to `.cjs` extension

### main

Define the entry file of the package

For example, when you download package `A` in the project and introduce it through `import A from 'A'`, the actual search is the path defined by `node_modules/A/main`:

### module

The `module` field was first proposed by `rollup` and has not yet been mentioned in the Chinese official website. The purpose is to provide an entrance to `ESModule` so that the packager can use the static analysis capability of `ESModule` to implement the `TreeShaking` function

If the packager supports the `module` field, when looking for the package, it will first try to read the `module` corresponding file with the `ESModule` rule.

### browser

In packages such as `Axios` that support both the `node` side and the browser side, different environments may depend on different modules (the `node` environment in `Axios` uses `http` requests, and the browser environment uses `xhr `request), the `browser` field is to better realize this function

When using a packager such as `webpack`, if the specified environment `target` is `web`, the file rules specified in this field will be used

Supports a single attribute, representing the entry file. It also supports defining multiple key-value pairs to represent replacement paths.

```json
// A single field represents the entry file as the browser environment
"browser": "./lib/browser/main.js"
// When specifying a key-value pair, when parsing the corresponding key, the path to the corresponding value will be replaced.
"browser": {
   "module-a": "./browser/module-a.js",
   "./server/module-b.js": "./browser/module-b.js",
   // It also supports configuring false to prevent the module from being loaded.
   "module-c": false
}
```

### exports

As an alternative to `main` and `module`, when multiple fields exist at the same time, `exports` will be used first.

Multiple entry points are allowed to be defined. For cases where there are few exposed entries, officials recommend explicitly specifying each entry point; when there are too many exposed entries, the entire folder can be exported directly.

```json
{
  "exports": {
    // Explicitly specify each entry point
    ".": "./lib/index.js",
    "./lib": "./lib/index.js",
    // The official recommendation is to provide both subpaths with extensions and without extensions.
    "./lib/index": "./lib/index.js",
    "./lib/index.js": "./lib/index.js",
    // Export the entire folder
    "./feature/*": "./lib/feature/*.js",
    // When there are entry points in the export folder that you do not want to expose, you can explicitly specify not to expose them.
    "./feature/internal/*": null
  }
}
```

**Each path should be equivalent to the package root directory**. When only the root directory is exposed, it can be abbreviated as: `"exports": "./index.js"`

<hr />

Support conditional export, common conditions include `import`, `require`, `default`

```json
{
  "exports": {
    //When importing using import, load the mjs file
    "import": "./index.mjs",
    //When using require to import, load the cjs file
    "require": "./index.cjs",
    // default is a general fallback option and should always be placed last
    "default": "./index.js"
  },
  // Can also be used to export sub-paths
  "exports": {
    ".": "./index.js",
    "./feature": {
      "import": "./feature/index.mjs",
      "require": "./feature/index.cjs"
    }
  }
}
```

**After defining `exports`, an `ERR_PACKAGE_PATH_NOT_EXPORTED` error will be thrown when importing a path other than the entry point**

### name

Define the package name, that is, the name published to the `npm` warehouse, which needs to comply with [naming rules](https://nodejs.cn/npm/cli/v8/configuring-npm/package-json/#name)

::: tip
The meaning of the package name in the format of `@a/b` is the package named `b` in the range of `a`, and the `@` and `/` inside belong to the naming convention. The function of the scope is to organize a series of related packages together, and more importantly, there is no need to worry about duplicate package names. How to publish the scope, refer to [official document](https://nodejs.cn/npm/cli/v8/using-npm/scope/#)
:::

### packageManager

As of the time of publication, it is still in the experimental stage and requires `NodeJS` version to be greater than or equal to `16.9.0`. Based on the `corepack` package included in the new version of `node`, it is used to unify the project package manager. For details, please refer to [this article](https://www.jianshu.com/p/c239ed5dedd6)

> If you use NVM, Volta and other tools to manage the Node version, the corepack command may not be available. You can find the solution in the official issue

## Common fields of package managers

### scripts

The running script of the package itself, such as the startup method of this document:

```json
{
  "scripts": {
    "dev": "vitepress dev"
  }
}
```

The corresponding `vitepress dev` command can be called through `npm run dev`

<hr />

`npm` also provides pre and post script keywords `pre` and `post`, for example

```json
{
  "scripts": {
    "preecho": "",
    "echo": "",
    "postecho": ""
  }
}
```

After executing `npm run echo`, `preecho`, `echo` and `postecho` will be called respectively.

In addition, some specific scripts are provided, you can view the [official documentation] yourself (https://nodejs.cn/npm/cli/v8/using-npm/scripts/#life-cycle-scripts)

### config

The `config` field is used to add command line environment variables. After adding, the added environment variables can be used in the scripts specified in the `scripts` field.

```json
{
  "config": { "port": "8888" },
  "scripts": { "start": "node server.js" }
}
```

```js
// server.js
console.log(process.env.npm_package_config_port) // 8888
```

### dependencies

```shell
# i is the abbreviation of the full name install command
# You don’t need to add the common --save or -S
# @version can be omitted, default is the latest stable version
npm i lib-name@version
pnpm i lib-name@version
yarn add lib-name@version
```

Runtime dependencies (core files related to running), including package name and version mapping. When installed through the package manager, the package name and version will be automatically added to `dependencies`.

The standard project version rules are usually: `major version number. minor version number. revision number - pre-release label. pre-release version number`, for example `vitepress` current version `1.0.0-alpha.49`. For details, please check [semver](https://github.com/npm/node-semver#versions)

A range character can be specified before the version number, including:

- `<`: less than the specified version number
- `<=`: less than for the specified version number
  -Similar to `>` and `>=`
- `=`: With the specified version number system, the equal sign can be omitted
- Range identifiers can be mixed, such as `>=1.2.0<2.0.0`, or `1.2.0-2.0.0`
- `||`: Specify multiple version ranges
- `x`: can be used as a wildcard, for example `1.x` means the main version is 1, the minor version, and the revision is any
- `~`: Specify the range from version to minor version +1
- `^`: Specifies the range from the specified version to the first non-0 version number + 1
- `*`: matches any range
- `tag` tag: matches a specific version published as `tag`, such as `latest` tag

Pre-release tags are usually divided into alpha and beta. An alpha version indicates that work is under development and can be considered a technology preview, while a beta version indicates that the product is ready for release and can be considered a test version. When a pre-release tag exists, even if a range character is used, the major version number, minor version number, and revision number must be the same.

### devDependencies

```shell
# -D can also be written as --save-dev
npm i lib-name@version -D
pnpm i lib-name@version -D
yarn add lib-name@version -D
```

Dependencies during development (such as code formatting, testing, etc., have nothing to do with theme functions), the content is the same as `dependencies`. `xxx` is automatically added to `de when installing via the package managervDependencies`

In projects that are not published as packages, there is no difference between `dependencies` and `devDependencies`, because the packager reads the files as imported and has nothing to do with dependencies

But if the project is to be released as a package, when users introduce your package, only the dependencies in `dependencies` will be downloaded.

### peerDependencies

```shell
npm i lib-name@version --save-peer
pnpm i lib-name@version --save-peer
yarn add lib-name@version --save-peer
```

Used to specify the host environment required by the current package. The content is the same as `dependencies`. It is usually used in plug-ins.

For example, when developing a `vue` plug-in, if `vue` is placed in `dependencies`, when the user references your plug-in in a project where `vue` is already installed, `vue` will be installed again, causing waste. If defined in `peerDependencies`, `npm install` will not reinstall `vue` by default. As long as the defined version number matches the version number already installed by the user, it can be used directly. If the user has not installed the corresponding version of `vue`, the user will be prompted that `peerDependencies` are not installed.

### files

Define which files will only be included when the package is installed as a dependency. The default `["*"]` is all files.

No matter how set up, `package.json`, `README`, `LICENSE/LICENCE`, `main` field files will always contain

On the contrary, files such as `.git` will be ignored

###bin

Define executable commands and add them to the system environment variables, such as `zx` used in this document:

```json
{
  "bin": {
    "zx": "./build/cli.js"
  },
  // It can also be abbreviated. In this case, the command name is the package name.
  "bin": "./build/cli.js"
}
```

### engines

Specify the applicable `node` version, the version rules are the same as dependencies

```json
{
  "engines": {
    "node": ">=14.0.0"
  }
}
```

### version

The version number published to `npm`

### description

Package introduction

### keywords

Package keyword, used to discover your package in `npm`

### homepage

Project homepage address

### bugs

Project issue tracking address or email address

```json
{
  "url": "For example, github issue page address",
  "email": "email@xxx.com"
}
```

### license

The license used by the project indicates how others can use your open source project

### authors, contributors

project developer

```json
{
   "author": {
     "name": "",
     "email": "",
     "url": ""
   },
   // Or reduce it to one line
   "author": "name <email> (url)"
   //Contributors format is the same as author
   "contributors": [
     {...},
     {...}
   ]
}
```

### repository

The location of the package code, such as the `github` repository

```json
{
  "repository": {
    "type": "git",
    "url": "https://github.com/Xaviw/XaviDocs.git",
    // If the package is part of a monorepo (multiple packages under one project), you can specify the directory where the package is located.
    "directory": "packages/react-dom"
  }
}
```

### private

If set to `true`, `npm` will refuse to publish the package

### preferGlobal

When set to `true`, a warning will be displayed if the user installs the package without using the `--global` parameter
